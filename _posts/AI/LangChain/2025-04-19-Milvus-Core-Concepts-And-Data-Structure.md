---
title: Milvus Core Concepts and Data Structures
date: 2025-04-19
categories: [AI, LangChain]
tags: [LangChain, Vector Database, Milvus, Collection, Entity, Field, Similarity]
author: kai
---

# üöÄ Milvus Core Concepts and Data Structures
Milvus is a high-performance vector database designed specifically for managing and querying massive amounts of vector data. To help understand its internal model, here‚Äôs how **Milvus concepts** map to traditional **relational database (RDBMS)** concepts.

**Install the Milvus SDK:**
`pip install pymilvus==2.5.5`

## üîÅ Milvus vs Relational Database: Concept Mapping

| Milvus Concept        | Relational DB Equivalent | Description |
|------------------------|---------------------------|-------------|
| **Collection**         | Table                     | A collection is a schema-defined container that stores vector and scalar data, similar to a table in an RDBMS. |
| **Entity**             | Row                       | An entity represents a single data entry or object, including its vector and scalar fields. |
| **Field**              | Column                    | Each field defines a specific data type, such as integers, strings, or vectors. |



## üì¶ Collections
In Milvus, a **Collection** is the fundamental data structure for storing and organizing data‚Äîsimilar to a **table** in traditional relational databases. Each collection holds multiple **entities**, and all entities within a collection follow the same **schema**.

- A **Collection** defines the structure and behavior of the data you store.
- It consists of:
  - **FieldSchema**: Definitions for each field (primary key, vector, scalar).
  - **CollectionSchema**: A collection-wide schema including all fields.
- Since Milvus 2.3+, it also supports:
  - **Dynamic fields**: Optional flexible field types.
  - **Auto-generated IDs**: Milvus can automatically assign unique primary keys if not provided.

### Example: Creating a Collection in Python

```python
from pymilvus import Collection, FieldSchema, CollectionSchema, DataType  

# Define fields: 
fields = [  
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),       # Scalar Fields
    FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=768),    # Vector Fields
    FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=50)  # Scalar Fields
]  

# Create collection
schema = CollectionSchema(fields, description="Products Vector Database")  
collection = Collection(name="products", schema=schema)  
```


## üîë Entity
In Milvus, an **Entity** represents **a single record in a collection** ‚Äî much like a row in a traditional database table. Each entity comprises multiple fields: **a primary key, one or more scalar fields, and at least one vector field**.

| Component       | Description                                                                 |
|------------------|-----------------------------------------------------------------------------|
| **Primary Key**   | Uniquely identifies the entity. Can be an `INT64` or `VARCHAR`.            |
| **Vector Field**  | A fixed-length floating-point array (e.g., 768-dimensional embeddings).     |
| **Scalar Fields** | Metadata or structured data such as price, category, flags, timestamps.    |


### Example: Data Storage Structure

| ID (INT64) | Vector (FLOAT_VECTOR[768])   | Category (VARCHAR) | Price (FLOAT) |
|------------|-------------------------------|---------------------|----------------|
| 1001       | [0.12, 0.34, ..., 0.98]       | "Electronics"       | 299.99         |
| 1002       | [0.55, 0.21, ..., 0.11]       | "Clothing"          | 89.99          |


### Summary

- **Entity** = Primary Key + Vector + Scalar fields
- Designed for fast **vector search** + **metadata filtering**
- Primary Key **is not deduplicated** ‚Äî manage uniqueness in application logic
- A single Collection may contain **millions to billions** of entities

> ‚ö†Ô∏è **Note:** Milvus does not enforce uniqueness of primary keys ‚Äî duplicates are allowed.


## üìå Field
Milvus supports two primary types of fields within a **Collection Schema**: **Vector Fields** and **Scalar Fields**. Each serves a distinct purpose in vector similarity search and metadata filtering.

### 1. Vector Fields
**Definition:**  
A vector field stores high-dimensional data, typically generated by embedding models (e.g., sentence embeddings, image embeddings).

**Key Characteristics:**
- Data type: `FLOAT_VECTOR` or `BINARY_VECTOR` ...
- Required for similarity search (e.g., cosine similarity, Euclidean distance)
- Must define `dim` (dimension size, e.g., 768 for BERT embeddings)

### 2. Scalar Fields
**Definition:**
Scalar fields store traditional structured metadata alongside vectors, such as IDs, categories, timestamps, or numerical values.

**Key Characteristics:**
- Data type: `INT64 ` or `FLOAT` or `VARCHAR` ...
- Use Case: `"Filter where category = 'electronics' AND score > 0.9"`

## üëÄ Query
**Vector Field:** Similarity search -> Retrieve most similar documents, TopK

**Scalar Field:** Filtering & metadata storage -> Filter by category, date, score, etc.

**Combined Power: Filter + Search**

`Find top-5 similar items to a query vector WHERE category = 'book' AND rating > 4.5`


## üß© Data Organization & Scalability
Milvus uses a **multi-level data organization structure** to support high-performance querying and scalable storage. The three key components are **Partitions**, **Shards**, and **Segments**.


### Partition: Logical Data Segmentation

- **What it is**: A logical division within a collection.
- **Why it matters**: Helps reduce search space during queries by filtering specific partitions.
- **Common use cases**: Partitioning by time, region, category, etc.
- **Behavior**: Each partition may contain multiple shards and segments.

> Use partitions to logically organize large-scale datasets for faster query responses.


### Sharding: Parallelism for Write Scalability

- **What it is**: Automatic horizontal data distribution across storage nodes.
- **How it works**: On data insertion, Milvus hashes the primary key and routes the data to different shards.
- **Default setting**: Each collection has **2 shards** by default.
- **Benefit**: Enables **parallel writes** and better resource utilization.

> Sharding is transparent to the user and fully managed by Milvus internally.


### Segment: The Physical Storage Unit

- **Growth Segment**:
  - Temporarily stores newly inserted data.
  - Supports fast ingestion and indexing.

- **Sealed Segment**:
  - Persisted and optimized for efficient queries.
  - Automatically created from merged growth segments.

> Queries scan both sealed and growth segments to ensure accuracy.


## ‚öôÔ∏è Indexing
In vector databases like Milvus, **indexing** plays a crucial role in optimizing query performance‚Äîsimilar to how indexes work in MySQL.

### What Is an Index?

- An **index** is a specialized data structure that enables **faster data lookup**.
- It does **not store actual data**, but rather **pointers** or **key-value pairs** to where the data is stored.
- In Milvus, indexes are built **on top of raw vector data** to accelerate vector similarity search.

> Each **vector field** in a collection can be assigned **only one index type** at a time.


### Why Use Indexes in Milvus?

- Without indexes, vector search uses brute-force methods (e.g., full scan), which are slow for large datasets.
- Indexes improve query performance while trading off between speed, accuracy, and memory usage.
- Milvus supports multiple index types to match different **dataset sizes**, **precision needs**, and **resource constraints**.

### Index Type Comparison

| Index Type | Best for                      | Memory Usage | Accuracy | Build Speed |
|------------|-------------------------------|--------------|----------|-------------|
| `FLAT`     | Small datasets, exact search  | üî¥ High       | ‚úÖ 100%   | ‚ö° Fast      |
| `IVF_FLAT` | Balanced use cases            | üü° Medium     | ‚úÖ 98%    | ‚ö° Fast      |
| `HNSW`     | High recall, fast search      | üî¥ High       | ‚úÖ 99%    | üê¢ Slow      |
| `IVF_PQ`   | Massive datasets, low memory  | üü¢ Low        | ‚ö†Ô∏è 95%    | ‚ö° Fast      |


## üìê Similarity Metrics in Vector Search
Vector similarity lies at the heart of many AI systems, from recommendation engines to semantic search. Here‚Äôs a breakdown of the **three most common similarity metrics** used in vector databases like Milvus.

### 1. Euclidean Distance (L2)

**Formula:**

    L2(A, B) = sqrt( (a1 - b1)^2 + (a2 - b2)^2 + ... + (an - bn)^2 )

**Meaning:**
- Measures the **straight-line distance** between two vectors.
- **Smaller distance = more similar**.

**Range:**  
0 (identical) to ‚àû (completely different)

**Use Case:**  
Great for scenarios where vector magnitude matters (e.g., image or sensor data).


### 2. Inner Product (Dot Product or IP)
[Inner Product]({{ site.baseurl }}/summation-dot-product-and-cosine-similarity/#-dot-product)


**Formula:**

    IP = a1*b1 + a2*b2 + ... + an*bn

**Meaning:**
- Measures the projection of one vector onto another.
- **Higher dot product = more similarity** (especially when vectors are aligned).

**Alternative Expression:**

    IP = ||A|| * ||B|| * cos(Œ∏)  
    (where Œ∏ is the angle between vectors)

**Use Case:**  
Works well with non-normalized embeddings, commonly used in recommender systems.



### 3. Cosine Similarity
[Cosine Similarity]({{ site.baseurl }}/summation-dot-product-and-cosine-similarity/#-cosine-similarity)

**Formula:**

    CosineSim(A, B) = (A ¬∑ B) / (||A|| * ||B||)

**Meaning:**
- Focuses on the angle between vectors, ignoring their magnitude.
- Returns values between -1 and 1:
  - 1 ‚Üí same direction (most similar)
  - 0 ‚Üí orthogonal (no relation)
  - -1 ‚Üí opposite direction (least similar)

**Use Case:**  
Best for text embeddings or when comparing documents semantically.


### Quick Comparison

| Metric             | Magnitude Sensitive | Output Range  | Good For                  |
|--------------------|---------------------|---------------|---------------------------|
| Euclidean Distance | ‚úÖ Yes              | 0 to ‚àû        | Image search, clustering  |
| Inner Product      | ‚úÖ Yes              | -‚àû to ‚àû       | Recommender systems       |
| Cosine Similarity  | ‚ùå No               | -1 to 1       | Text embeddings, NLP      |







<br>




---

üöÄ Stay tuned for more insights into LangChain and Vector Database!



